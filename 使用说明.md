# 如何在其他项目中引用 QUIC Gateway Client 模块

## 一、安装依赖

### 方法一：使用 go get 直接安装

在你的项目目录下运行以下命令获取最新版本：

```bash
go get github.com/laotiannai/quic_gwclient@latest
```

或指定具体版本号：

```bash
go get github.com/laotiannai/quic_gwclient@v1.0.0  # 替换为实际的最新版本号
```

### 方法二：手动添加到 go.mod

在你的项目的 `go.mod` 文件中添加以下依赖：

```
require github.com/laotiannai/quic_gwclient latest  // 使用最新版本
```

或指定具体版本：

```
require github.com/laotiannai/quic_gwclient v1.0.0  // 替换为实际的最新版本号
```

然后执行：

```bash
go mod tidy
```

### 方法三：使用特定分支或提交

如需使用特定分支或提交，可以这样引用：

```bash
# 引用特定分支
go get github.com/laotiannai/quic_gwclient@branch_name

# 引用特定提交
go get github.com/laotiannai/quic_gwclient@commit_hash
```

## 二、导入包的不同方式

### 基本用法

```go
import "github.com/laotiannai/quic_gwclient/pkg/client"
```

### 使用别名

```go
import quic "github.com/laotiannai/quic_gwclient/pkg/client"
```

### 一次性导入多个子包

```go
import (
    "github.com/laotiannai/quic_gwclient/pkg/client"
    "github.com/laotiannai/quic_gwclient/utils"
)
```

## 三、基本使用流程

### 1. 创建客户端配置

首先创建一个客户端配置对象，指定服务器ID、名称和会话ID：

```go
config := &client.Config{
    ServerID:   8903,           // 替换为目标服务器ID
    ServerName: "your_server",  // 替换为目标服务器名称
    SessionID:  "session-uuid", // 替换为会话ID，可使用uuid库生成
}
```

### 2. 初始化客户端

使用服务器地址和配置创建客户端实例：

```go
serverAddr := "example.com:8002"  // 替换为实际服务器地址和端口
client := client.NewTransferClient(serverAddr, config)
```

### 3. 连接服务器

使用带超时的上下文建立连接：

```go
// 创建带15秒超时的上下文
ctx, cancel := context.WithTimeout(context.Background(), 15*time.Second)
defer cancel()

// 连接服务器
if err := client.Connect(ctx); err != nil {
    log.Printf("连接服务器失败: %v", err)
}
defer client.Close()  // 确保在函数结束时关闭连接
```

### 4. 发送初始化请求

连接成功后，发送初始化请求：

```go
// 使用非加密方式发送初始化请求
sentBytes, receivedBytes, err := client.SendInitRequestNoAES()
if err != nil {
    log.Printf("初始化请求失败: %v", err)
}
log.Printf("初始化请求成功，发送: %d 字节，接收: %d 字节", sentBytes, receivedBytes)

// 或者使用加密方式发送初始化请求
// if err := client.SendInitRequest(); err != nil {
//     log.Fatalf("初始化请求失败: %v", err)
// }
```

### 5. 发送传输请求并获取响应

发送实际的数据请求，例如HTTP请求：

```go
// 准备HTTP请求内容
content := "GET /api/data HTTP/1.1\r\n" +
    "Host: example.com\r\n" +
    "Connection: close\r\n\r\n"

// 发送非加密请求
response, sentBytes, receivedBytes, err := client.SendTransferRequestNoAES(content)
if err != nil {
    log.Printf("传输请求失败: %v", err)
}

// 输出请求数据统计
log.Printf("传输请求成功，发送: %d 字节，接收: %d 字节", sentBytes, receivedBytes)

// 处理响应
log.Printf("收到响应: %s", string(response))
```

## 四、进阶用法

### 1. 带重试逻辑的连接

```go
func connectWithRetry(client *client.TransferClient, ctx context.Context) error {
    maxRetries := 3
    backoff := 1 * time.Second
    
    var err error
    for i := 0; i < maxRetries; i++ {
        err = client.Connect(ctx)
        if err == nil {
            return nil // 连接成功
        }
        
        log.Printf("连接失败 (尝试 %d/%d): %v", i+1, maxRetries, err)
        if i < maxRetries-1 {
            // 指数退避策略
            sleepTime := backoff * time.Duration(1<<i)
            log.Printf("等待 %v 后重试...", sleepTime)
            time.Sleep(sleepTime)
        }
    }
    
    return fmt.Errorf("连接失败，已重试%d次: %w", maxRetries, err)
}
```

### 2. 处理HTTP响应

```go
func processHTTPResponse(response []byte) (int, map[string]string, []byte, error) {
    // 将响应转换为字符串
    respStr := string(response)
    
    // 分离HTTP头和主体
    parts := strings.SplitN(respStr, "\r\n\r\n", 2)
    if len(parts) != 2 {
        return 0, nil, nil, fmt.Errorf("无效的HTTP响应格式")
    }
    
    // 解析头部
    headerLines := strings.Split(parts[0], "\r\n")
    if len(headerLines) == 0 {
        return 0, nil, nil, fmt.Errorf("无效的HTTP头")
    }
    
    // 解析状态行
    statusLine := headerLines[0]
    statusParts := strings.SplitN(statusLine, " ", 3)
    if len(statusParts) < 3 {
        return 0, nil, nil, fmt.Errorf("无效的HTTP状态行: %s", statusLine)
    }
    
    // 获取状态码
    statusCode, err := strconv.Atoi(statusParts[1])
    if err != nil {
        return 0, nil, nil, fmt.Errorf("无效的HTTP状态码: %s", statusParts[1])
    }
    
    // 解析其他头部字段
    headers := make(map[string]string)
    for i := 1; i < len(headerLines); i++ {
        line := headerLines[i]
        parts := strings.SplitN(line, ": ", 2)
        if len(parts) == 2 {
            headers[parts[0]] = parts[1]
        }
    }
    
    // 返回状态码、头部和响应体
    return statusCode, headers, []byte(parts[1]), nil
}
```

### 3. 并发请求处理

```go
func sendConcurrentRequests(client *client.TransferClient, requests []string) [][]byte {
    var wg sync.WaitGroup
    responses := make([][]byte, len(requests))
    
    for i, req := range requests {
        wg.Add(1)
        go func(index int, request string) {
            defer wg.Done()
            
            resp, err := client.SendTransferRequestNoAES(request)
            if err != nil {
                log.Printf("请求 %d 失败: %v", index, err)
                return
            }
            
            responses[index] = resp
        }(i, req)
    }
    
    wg.Wait()
    return responses
}
```

## 五、完整示例

```go
package main

import (
    "context"
    "fmt"
    "log"
    "strings"
    "time"
    "strconv"

    "github.com/google/uuid"
    "github.com/laotiannai/quic_gwclient/pkg/client"
)

func main() {
    // 设置日志
    log.SetFlags(log.Ldate | log.Ltime | log.Lmicroseconds)
    log.Println("启动 QUIC Gateway 客户端...")
    
    // 生成唯一会话ID
    sessionID := uuid.New().String()
    
    // 创建客户端配置
    config := &client.Config{
        ServerID:   8903,
        ServerName: "test_server",
        SessionID:  sessionID,
    }
    
    // 初始化客户端
    serverAddr := "example.com:8002"
    c := client.NewTransferClient(serverAddr, config)
    
    // 带重试的连接逻辑
    ctx, cancel := context.WithTimeout(context.Background(), 30*time.Second)
    defer cancel()
    
    if err := connectWithRetry(c, ctx); err != nil {
        log.Fatalf("无法连接到服务器: %v", err)
    }
    defer c.Close()
    
    // 发送初始化请求
    sentBytes, receivedBytes, err := c.SendInitRequestNoAES()
    if err != nil {
        log.Fatalf("初始化请求失败: %v", err)
    }
    log.Printf("初始化成功，发送: %d 字节，接收: %d 字节", sentBytes, receivedBytes)
    
    // 准备HTTP请求
    httpRequest := fmt.Sprintf(
        "GET /api/data HTTP/1.1\r\n"+
        "Host: example.com\r\n"+
        "User-Agent: QuicGatewayClient/1.0\r\n"+
        "Accept: */*\r\n"+
        "Connection: close\r\n\r\n")
    
    // 发送请求并获取响应
    log.Println("发送HTTP请求...")
    response, sentBytes, receivedBytes, err := c.SendTransferRequestNoAES(httpRequest)
    if err != nil {
        log.Fatalf("请求失败: %v", err)
    }
    
    log.Printf("传输请求成功，发送: %d 字节，接收: %d 字节", sentBytes, receivedBytes)
    
    // 处理HTTP响应
    statusCode, headers, body, err := processHTTPResponse(response)
    if err != nil {
        log.Fatalf("处理响应失败: %v", err)
    }
    
    // 输出响应信息
    log.Printf("状态码: %d", statusCode)
    log.Printf("响应头: %v", headers)
    
    if contentType, ok := headers["Content-Type"]; ok {
        log.Printf("内容类型: %s", contentType)
        
        // 根据内容类型处理响应体
        if strings.Contains(contentType, "application/json") {
            log.Printf("JSON响应: %s", string(body))
        } else if strings.Contains(contentType, "text/html") {
            if len(body) > 100 {
                log.Printf("HTML响应 (前100字符): %s...", string(body[:100]))
            } else {
                log.Printf("HTML响应: %s", string(body))
            }
        } else {
            log.Printf("收到 %d 字节的数据", len(body))
        }
    } else {
        log.Printf("响应体: %s", string(body))
    }
    
    log.Println("请求完成")
}

// 连接重试函数
func connectWithRetry(client *client.TransferClient, ctx context.Context) error {
    maxRetries := 3
    backoff := 1 * time.Second
    
    var err error
    for i := 0; i < maxRetries; i++ {
        err = client.Connect(ctx)
        if err == nil {
            return nil
        }
        
        log.Printf("连接失败 (尝试 %d/%d): %v", i+1, maxRetries, err)
        if i < maxRetries-1 {
            sleepTime := backoff * time.Duration(1<<i)
            log.Printf("等待 %v 后重试...", sleepTime)
            time.Sleep(sleepTime)
        }
    }
    
    return fmt.Errorf("连接失败，已重试%d次: %w", maxRetries, err)
}

// 处理HTTP响应
func processHTTPResponse(response []byte) (int, map[string]string, []byte, error) {
    respStr := string(response)
    parts := strings.SplitN(respStr, "\r\n\r\n", 2)
    if len(parts) != 2 {
        return 0, nil, nil, fmt.Errorf("无效的HTTP响应格式")
    }
    
    headerLines := strings.Split(parts[0], "\r\n")
    if len(headerLines) == 0 {
        return 0, nil, nil, fmt.Errorf("无效的HTTP头")
    }
    
    statusLine := headerLines[0]
    statusParts := strings.SplitN(statusLine, " ", 3)
    if len(statusParts) < 3 {
        return 0, nil, nil, fmt.Errorf("无效的HTTP状态行: %s", statusLine)
    }
    
    statusCode, err := strconv.Atoi(statusParts[1])
    if err != nil {
        return 0, nil, nil, fmt.Errorf("无效的HTTP状态码: %s", statusParts[1])
    }
    
    headers := make(map[string]string)
    for i := 1; i < len(headerLines); i++ {
        line := headerLines[i]
        parts := strings.SplitN(line, ": ", 2)
        if len(parts) == 2 {
            headers[parts[0]] = parts[1]
        }
    }
    
    return statusCode, headers, []byte(parts[1]), nil
}
```

## 六、常见问题排查

1. **连接失败**
   - 检查服务器地址和端口是否正确
   - 确认服务器是否支持 QUIC 协议
   - 检查网络环境是否允许 UDP 流量
   - 使用 `wireshark` 捕获网络数据包分析问题

2. **初始化请求失败**
   - 检查 ServerID、ServerName 和 SessionID 是否正确
   - 确认服务器是否需要加密请求（尝试使用 `SendInitRequest()` 代替 `SendInitRequestNoAES()`）

3. **传输请求超时或失败**
   - 检查请求格式是否正确
   - 确认服务器是否响应慢，尝试增加超时时间
   - 检查是否需要进行特定的认证流程

4. **响应数据解析错误**
   - 检查响应格式是否符合预期
   - 如果是二进制数据，使用适当的方法处理而非直接转为字符串 

## 七、字节统计功能

从版本X.X.X开始，本库增加了请求和响应字节数统计功能，可用于流量分析、性能监控和网络诊断。

### 1. 基本用法

现在 `SendInitRequestNoAES` 和 `SendTransferRequestNoAES` 函数返回的结果中包含字节统计信息：

```go
// 初始化请求
sentBytes, receivedBytes, err := client.SendInitRequestNoAES()

// 传输请求
response, sentBytes, receivedBytes, err := client.SendTransferRequestNoAES(content)
```

### 2. 流量统计示例

```go
// 记录总流量
var totalSentBytes, totalReceivedBytes int

// 发送初始化请求
initSent, initReceived, err := client.SendInitRequestNoAES()
if err != nil {
    log.Fatalf("初始化请求失败: %v", err)
}

totalSentBytes += initSent
totalReceivedBytes += initReceived

// 发送多个传输请求
for _, request := range requests {
    resp, sent, received, err := client.SendTransferRequestNoAES(request)
    if err != nil {
        log.Printf("请求失败: %v", err)
        continue
    }
    
    totalSentBytes += sent
    totalReceivedBytes += received
    
    // 处理响应...
}

// 输出统计信息
log.Printf("总计发送: %d 字节, 接收: %d 字节", totalSentBytes, totalReceivedBytes)
log.Printf("平均每次请求发送: %.2f 字节, 接收: %.2f 字节", 
    float64(totalSentBytes)/float64(len(requests)+1), 
    float64(totalReceivedBytes)/float64(len(requests)+1))
```

### 3. 性能分析与监控

使用字节统计功能可以实现：

1. **网络效率分析**：计算请求和响应的大小比例
   ```go
   efficiency := float64(responseBytes) / float64(requestBytes)
   log.Printf("响应/请求比例: %.2f", efficiency)
   ```

2. **带宽使用监控**：测量传输速率
   ```go
   startTime := time.Now()
   response, sent, received, _ := client.SendTransferRequestNoAES(largeRequest)
   duration := time.Since(startTime)
   
   sendBandwidth := float64(sent) / duration.Seconds() / 1024 // KB/s
   receiveBandwidth := float64(received) / duration.Seconds() / 1024 // KB/s
   
   log.Printf("上传带宽: %.2f KB/s, 下载带宽: %.2f KB/s", sendBandwidth, receiveBandwidth)
   ```

3. **异常检测**：识别异常大的请求或响应
   ```go
   if sent > threshold || received > threshold {
       log.Printf("警告: 检测到异常大的数据传输: 发送=%d字节, 接收=%d字节", sent, received)
   }
   ``` 